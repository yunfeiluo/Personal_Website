{"0": {"obj": {"docs": [{"docs": [], "path": "articles/documentations/personal_website/Requirements.pdf", "text": "Personal Website, Requirements\nAuthor: Yunfei Luo\n1. Functionalities.\n1.1. Welcome page\nWhen user navigate to the website, there is a clean-style page, with brief introduction, links to the documents, and nice pictures. There is also a footer at the bottom of the webpage, containing the linkedin, github, and my contact information. This footer will be shown in all the webpages on the website. \n\n1.2. Navigation to documents\nUser click on the link with either: \ni) navigate to software engineering documentations\nii) navigate to reports of open source projects\niii) navigate to blogs\niv) navigate to search area! :)\nFor the first three cases, the list of corresponding documents will be shown with a clean style. When user click on the title, the documents need to be shown explicitly. AND, there need to be a back button to let the user navigate back to the list page. \n\n1.3. Search for relevant document(s)\nUser click into the search area. They will search with key words: blogs, reports, image process, language model, what is search engine, what is this, to be or not to be, hey what's up! ...\n\nThe retrieved list will be shown in the same form mentioned in 1.2. The search bar will keep at the top of the webpage. The user could either click the document for reading (also same scenario in 1.2.), or try another query, or close the browser. \n\n2. Non-Functionalities.\n2.1. Development Schema: Waterfall, CI/CD\nSince this is a personal project, waterfall pattern is a proper way to keep the progress going forward stably and correctly. Continuous Integration enable the consistency of codes among local development branch and the remote master branch. \n\n2.2. Front-end Tool(s): React\nThe render functionality of React enables the concise response the quick and temporary click actions. The JSX syntax enables the effective development, and makes the code more readable. \n\n2.3. Back-end Tool(s): Flask, AWS\nFlask is used for local testing, i.e. setup a local server, and test the interactions between front-end and back-end. \n\nAWS provide cloud services that enables the quick deployment. The services that will be used include: S3 bucket for server, Lambda functions for handling events, API Gateway for the communication between front-end and back-end, and Relational Database Service for indexing the articles. \n\n2.4. Version Control: Github\nA widely recognized tool for version control. Github offer clean interface to trace the issues, and push/pull requests. ", "id": 2, "summery": "The functionalities and the non-functionalities of the personal website project; stating the reasons for the chosen tools and patterns.", "tags": ["Software Engineering", "Full Stack"], "type": "documentation", "title": "Requirements Analysis, Personal Website"}, {"docs": [], "path": "articles/documentations/personal_website/high_level_design.pdf", "text": "1. Overview.\nFigure 1. Entire Architecture\n \n2. Front-end Schema.\nFigure 2. Frontend Architecture\n \nHomepage is the node connecting the website to with users. Search page is the node connecting the frontend to the backend. Both Homepage and Search page navigate to the article pages.\n \nEvery pages return to the homepage. \n \nEvery pages contain Contact info in the footer. \n \n3. Back-end Scheme.\nFigure 3. Backtend Architecture.\n \nEvent Handler is the node receiving requests from the frontend. It will run the micro search engine, and return the result back to the frontend. \n \nWithin the micro search engine, the Store Documents and Index contains the data needed for retrieving the documents. The retrieval model rank the documents based on the stored data, and return the result back to the Event handler node. \n \n4. Database Schema.\nincludegraphics[scale=0.21]{article_stored.jpg}\nFigure 4. table for storing Article object\n \nEach article has a unique id. Type attribute could be ${$blogs, reports, documentations$}$. Path attribute specifies where the document stored. Docs attribute points to other documents that is within the scope of project of the Article object. ", "id": 3, "summery": "Displaying the Entire Architecture of the personal website project; Schemas for Front-end, Back-end, and Database.", "tags": ["Software Engineering", "Full Stack"], "title": "High Level Design, Personal Website", "type": "documentation"}, {"docs": [], "path": "articles/documentations/personal_website/low_level_design_search_engine.pdf", "text": "\title{Personal Website, Low Level Design, Search Engine}\n\\author{Author: Yunfei Luo}\n\\maketitle\n\n------------------------------------------------------------------------------------------------------------------------\n\\ \\\n\textbf{1. Overview.}\n\\ \\\n\\includegraphics[scale=0.28]{back_end_overview.jpg}\\\n\\centerline{\textbf{Figure 1. }Micro Search Engine Architecture}\n\\ \\\n\textbf{2. Pre-processing.}\\\n\textbf{2.1. Processing Documents.}\\\nThis is independent with the interaction between frontend and backend. This process need to be done periodically, or whenever there are new articles added to the database. \n\\ \\\nThe process follows steps:\\\ni) tokenize, all letter to lower case, and remove dot between abbreviation words. \\\nii) stemming, use Snowball stemmer, also called Porter 2. \\\niii) stopword removal, remove non-significant words, use the concise list from python package: nltk.  \\\n\\ \\\n\\ \\\n\textbf{2.2. Processing Queries.}\\\nWhen ever there is a query request coming from frontend, the query terms will first be pre-processed, then the querying functions will be executed. The processing steps are the same as steps for processing documents, see 2.1.\n\\ \\\n\textbf{3. Indexing (Inverted Index).}\\\nIndexing will be mainly used by the retrieval model to rank the documents given the query terms. Inverted Index is a inverted list, that contains the necessary information for each stored terms. More specifically, the inverted index is defined as:\\\n$$map: term \\mapsto (map: document\\_id \\mapsto list(positions))$$\nFor example, term $learning$ occur in document 1 and 3. It is the first and fifth word of document 1, and second and forth word of document 2, then the index for this term would looks like:\n$$learning \\mapsto \\{document_1 \\mapsto [1, 5], document_3 \\mapsto [2, 4] \\}$$\nThen the term frequency in a document is $length(term.doc\\_id)$, i.e. the total length of the list of positions in document with specified id. The collection frequency is the length of the list for a term. \n\\ \\\n\textbf{4. Retrieval Models.}\\\nThe key element for ranking the documents given the query terms. The following are the options of algorithms. \n\\ \\\n\textbf{4.1. BM25. (formula information reference from: Search Engines,\nInformation Retrieval in Practice, by W.B. Croft, D. Metzler, T. Strohman, 2015)}\\\nBM25 (BM stands for Best Match) is a well-known probabilistic retrieval model that not only take the document term frequency into account, but also consider the query term frequency. In the micro search engine, we will use the most common form of BM25, with no reference information. More specifically, the score for a document given the query terms is calculated by:\n$$\\sum_{i \\in Q} \\log(\frac{N-n_i+0.5}{n_i+0.5}) \\cdot \frac{(k_1+1)f_i}{K + f_i} \\cdot \frac{(k_2+1)qf_i}{k_2+qf_i}$$\nWhere $Q$ is the set of terms in the query terms, $N$ is the total number of documents we have, $n_i$ is the document frequency, i.e. number of documents that contain term $i$. $f_i$ is the term frequency in the document, and $qf_i$ is the term frequency in the query terms. The weighting parameters $k_1, k_2, K$ are set empirically (by science). $k_1$ and $k_2$ determine the importance of document term frequency and query term frequency respectively. $K$ is a normalized term, determined by:\n$$K = k_1((1-b)+b\\cdot \frac{dl}{avdl})$$\nWhere $b$ is a empirical parameter, $dl$ is the document length, and $avdl$ is the average length of all the documents we have. \n\\ \\\nWe could set the magic parameters to $k_1=1.1, k_2=10, b=0.6$. \n\\ \\\n\textbf{4.2. Query Likelihood. (formula information reference from: Search Engines,\nInformation Retrieval in Practice, by W.B. Croft, D. Metzler, T. Strohman, 2015)}\\\nQuery Likelihood is a well-known probabilistic retrieval model depends on language model. The smoothing techniques we use is Dirichlet smoothing. More specifically, we calculate the score for a document by:\n$$\\alpha_D P(q_i|D) + \\alpha_D P(q_i|C)$$\nwhere $P(q_i|D)$ is the probability of query term $i$ occur in document $D$, and $P(q_i|C)$ is the probability of query term $i$ occur in the entire collection $C$. $\\alpha_D$ is the Dirichlet smoothing coefficient determined by $\\alpha_D = \frac{\\mu}{|D| + \\mu}$, where $\\mu$ is set empirically. The final formula is:\n$$\frac{f_{q_i, D} + \\mu \frac{c_{q_i}}{|C|}}{|D| + \\mu}$$\nwhere $f_{q_i, D}$ is the term frequency in document $D$, and $c_{q_i}$ is the term frequency in entire collection $C$. We could set $\\mu = 1000$. ", "id": 4, "summery": "Details of the micro search engine, including the steps for query processing, indexing techniques, and retrieval models.", "tags": ["Software Engineering", "Full Stack", "Search Engine"], "title": "Low level Design -- Search Engine, Personal Website", "type": "documentation"}], "path": "articles/documentations/personal_website/Introduction.pdf", "text": "Personal Website Introduction\nAuthor: Yunfei Luo\nThis website was mainly designed for representing the Software Engineering and open source projects that I've\ndone or participated in.\n\\ \\\nThere are reports and documentaions of the projects. Moreover, there are blogs, include the reflections and discussions on the papers of the related fields that I've read. The blogs also include some of my learning\nnotes on the significant concepts in the engineering (application) field. \n\\ \\\nThere is a micro-search-engine implemented in the backend to enable the search functionalities. Since the articles are stored structured in a retrospective way, they are easy to be retrieved and be able to concisely displayed to the readers.\n\\ \\\nThe website well-come all readers who are interested in the topics of these articles. Enjoy the reading! ", "id": 1, "summery": "This website was mainly designed for representing the Software Engineering and open source projects that I've done or participated in.", "tags": ["Software Engineering", "Full Stack"], "type": "documentation", "title": "Personal Website, Software Engineering Project"}, "text": ["person", "websit", "introduct", "author", "yunfei", "luo", "websit", "main", "design", "repres", "softwar", "engin", "open", "sourc", "project", "ve", "done", "particip", "report", "documentaion", "project", "moreov", "blog", "includ", "reflect", "discuss", "paper", "relat", "field", "ve", "read", "blog", "includ", "learn", "note", "signific", "concept", "engin", "applic", "field", "micro", "search", "engin", "implement", "backend", "enabl", "search", "function", "sinc", "articl", "store", "structur", "retrospect", "way", "easi", "retriev", "abl", "concis", "display", "reader", "websit", "come", "reader", "interest", "topic", "articl", "enjoy", "read"]}, "1": {"obj": {"docs": [], "path": "articles/documentations/personal_website/Requirements.pdf", "text": "Personal Website, Requirements\nAuthor: Yunfei Luo\n1. Functionalities.\n1.1. Welcome page\nWhen user navigate to the website, there is a clean-style page, with brief introduction, links to the documents, and nice pictures. There is also a footer at the bottom of the webpage, containing the linkedin, github, and my contact information. This footer will be shown in all the webpages on the website. \n\n1.2. Navigation to documents\nUser click on the link with either: \ni) navigate to software engineering documentations\nii) navigate to reports of open source projects\niii) navigate to blogs\niv) navigate to search area! :)\nFor the first three cases, the list of corresponding documents will be shown with a clean style. When user click on the title, the documents need to be shown explicitly. AND, there need to be a back button to let the user navigate back to the list page. \n\n1.3. Search for relevant document(s)\nUser click into the search area. They will search with key words: blogs, reports, image process, language model, what is search engine, what is this, to be or not to be, hey what's up! ...\n\nThe retrieved list will be shown in the same form mentioned in 1.2. The search bar will keep at the top of the webpage. The user could either click the document for reading (also same scenario in 1.2.), or try another query, or close the browser. \n\n2. Non-Functionalities.\n2.1. Development Schema: Waterfall, CI/CD\nSince this is a personal project, waterfall pattern is a proper way to keep the progress going forward stably and correctly. Continuous Integration enable the consistency of codes among local development branch and the remote master branch. \n\n2.2. Front-end Tool(s): React\nThe render functionality of React enables the concise response the quick and temporary click actions. The JSX syntax enables the effective development, and makes the code more readable. \n\n2.3. Back-end Tool(s): Flask, AWS\nFlask is used for local testing, i.e. setup a local server, and test the interactions between front-end and back-end. \n\nAWS provide cloud services that enables the quick deployment. The services that will be used include: S3 bucket for server, Lambda functions for handling events, API Gateway for the communication between front-end and back-end, and Relational Database Service for indexing the articles. \n\n2.4. Version Control: Github\nA widely recognized tool for version control. Github offer clean interface to trace the issues, and push/pull requests. ", "id": 2, "summery": "The functionalities and the non-functionalities of the personal website project; stating the reasons for the chosen tools and patterns.", "tags": ["Software Engineering", "Full Stack"], "type": "documentation", "title": "Requirements Analysis, Personal Website"}, "text": ["person", "websit", "requir", "author", "yunfei", "luo", "1", "function", "11", "welcom", "page", "user", "navig", "websit", "clean", "style", "page", "brief", "introduct", "link", "document", "nice", "pictur", "footer", "bottom", "webpag", "contain", "linkedin", "github", "contact", "inform", "footer", "webpag", "websit", "12", "navig", "document", "user", "click", "link", "navig", "softwar", "engin", "document", "ii", "navig", "report", "open", "sourc", "project", "iii", "navig", "blog", "iv", "navig", "search", "area", "three", "case", "list", "correspond", "document", "clean", "style", "user", "click", "titl", "document", "explicit", "back", "button", "user", "navig", "back", "list", "page", "13", "search", "relev", "document", "s", "user", "click", "search", "area", "search", "key", "word", "blog", "report", "imag", "process", "languag", "model", "search", "engin", "hey", "s", "", "", "", "retriev", "list", "form", "mention", "12", "search", "bar", "keep", "top", "webpag", "user", "click", "document", "read", "scenario", "12", "tri", "anoth", "queri", "close", "browser", "2", "non", "function", "21", "develop", "schema", "waterfal", "ci", "cd", "sinc", "person", "project", "waterfal", "pattern", "proper", "way", "keep", "progress", "stabli", "correct", "continu", "integr", "enabl", "consist", "code", "local", "develop", "branch", "remot", "master", "branch", "22", "end", "tool", "s", "react", "render", "function", "react", "enabl", "concis", "respons", "quick", "temporari", "click", "action", "jsx", "syntax", "enabl", "effect", "develop", "make", "code", "readabl", "23", "back", "end", "tool", "s", "flask", "aw", "flask", "local", "test", "setup", "local", "server", "test", "interact", "end", "back", "end", "aw", "provid", "cloud", "servic", "enabl", "quick", "deploy", "servic", "includ", "s3", "bucket", "server", "lambda", "function", "handl", "event", "api", "gateway", "communic", "end", "back", "end", "relat", "databas", "servic", "index", "articl", "24", "version", "control", "github", "wide", "recogn", "tool", "version", "control", "github", "offer", "clean", "interfac", "trace", "issu", "push", "pull", "request"]}, "2": {"obj": {"docs": [], "path": "articles/documentations/personal_website/high_level_design.pdf", "text": "1. Overview.\nFigure 1. Entire Architecture\n \n2. Front-end Schema.\nFigure 2. Frontend Architecture\n \nHomepage is the node connecting the website to with users. Search page is the node connecting the frontend to the backend. Both Homepage and Search page navigate to the article pages.\n \nEvery pages return to the homepage. \n \nEvery pages contain Contact info in the footer. \n \n3. Back-end Scheme.\nFigure 3. Backtend Architecture.\n \nEvent Handler is the node receiving requests from the frontend. It will run the micro search engine, and return the result back to the frontend. \n \nWithin the micro search engine, the Store Documents and Index contains the data needed for retrieving the documents. The retrieval model rank the documents based on the stored data, and return the result back to the Event handler node. \n \n4. Database Schema.\nincludegraphics[scale=0.21]{article_stored.jpg}\nFigure 4. table for storing Article object\n \nEach article has a unique id. Type attribute could be ${$blogs, reports, documentations$}$. Path attribute specifies where the document stored. Docs attribute points to other documents that is within the scope of project of the Article object. ", "id": 3, "summery": "Displaying the Entire Architecture of the personal website project; Schemas for Front-end, Back-end, and Database.", "tags": ["Software Engineering", "Full Stack"], "title": "High Level Design, Personal Website", "type": "documentation"}, "text": ["1", "overview", "figur", "1", "entir", "architectur", "2", "end", "schema", "figur", "2", "frontend", "architectur", "homepag", "node", "connect", "websit", "user", "search", "page", "node", "connect", "frontend", "backend", "homepag", "search", "page", "navig", "articl", "page", "everi", "page", "return", "homepag", "everi", "page", "contain", "contact", "info", "footer", "3", "back", "end", "scheme", "figur", "3", "backtend", "architectur", "event", "handler", "node", "receiv", "request", "frontend", "run", "micro", "search", "engin", "return", "result", "back", "frontend", "micro", "search", "engin", "store", "document", "index", "contain", "data", "retriev", "document", "retriev", "model", "rank", "document", "base", "store", "data", "return", "result", "back", "event", "handler", "node", "4", "databas", "schema", "includegraph", "scale", "0", "21", "articl", "store", "jpg", "figur", "4", "tabl", "store", "articl", "object", "articl", "uniqu", "id", "type", "attribut", "blog", "report", "document", "", "path", "attribut", "specifi", "document", "store", "doc", "attribut", "point", "document", "scope", "project", "articl", "object"]}, "3": {"obj": {"docs": [], "path": "articles/documentations/personal_website/low_level_design_search_engine.pdf", "text": "\title{Personal Website, Low Level Design, Search Engine}\n\\author{Author: Yunfei Luo}\n\\maketitle\n\n------------------------------------------------------------------------------------------------------------------------\n\\ \\\n\textbf{1. Overview.}\n\\ \\\n\\includegraphics[scale=0.28]{back_end_overview.jpg}\\\n\\centerline{\textbf{Figure 1. }Micro Search Engine Architecture}\n\\ \\\n\textbf{2. Pre-processing.}\\\n\textbf{2.1. Processing Documents.}\\\nThis is independent with the interaction between frontend and backend. This process need to be done periodically, or whenever there are new articles added to the database. \n\\ \\\nThe process follows steps:\\\ni) tokenize, all letter to lower case, and remove dot between abbreviation words. \\\nii) stemming, use Snowball stemmer, also called Porter 2. \\\niii) stopword removal, remove non-significant words, use the concise list from python package: nltk.  \\\n\\ \\\n\\ \\\n\textbf{2.2. Processing Queries.}\\\nWhen ever there is a query request coming from frontend, the query terms will first be pre-processed, then the querying functions will be executed. The processing steps are the same as steps for processing documents, see 2.1.\n\\ \\\n\textbf{3. Indexing (Inverted Index).}\\\nIndexing will be mainly used by the retrieval model to rank the documents given the query terms. Inverted Index is a inverted list, that contains the necessary information for each stored terms. More specifically, the inverted index is defined as:\\\n$$map: term \\mapsto (map: document\\_id \\mapsto list(positions))$$\nFor example, term $learning$ occur in document 1 and 3. It is the first and fifth word of document 1, and second and forth word of document 2, then the index for this term would looks like:\n$$learning \\mapsto \\{document_1 \\mapsto [1, 5], document_3 \\mapsto [2, 4] \\}$$\nThen the term frequency in a document is $length(term.doc\\_id)$, i.e. the total length of the list of positions in document with specified id. The collection frequency is the length of the list for a term. \n\\ \\\n\textbf{4. Retrieval Models.}\\\nThe key element for ranking the documents given the query terms. The following are the options of algorithms. \n\\ \\\n\textbf{4.1. BM25. (formula information reference from: Search Engines,\nInformation Retrieval in Practice, by W.B. Croft, D. Metzler, T. Strohman, 2015)}\\\nBM25 (BM stands for Best Match) is a well-known probabilistic retrieval model that not only take the document term frequency into account, but also consider the query term frequency. In the micro search engine, we will use the most common form of BM25, with no reference information. More specifically, the score for a document given the query terms is calculated by:\n$$\\sum_{i \\in Q} \\log(\frac{N-n_i+0.5}{n_i+0.5}) \\cdot \frac{(k_1+1)f_i}{K + f_i} \\cdot \frac{(k_2+1)qf_i}{k_2+qf_i}$$\nWhere $Q$ is the set of terms in the query terms, $N$ is the total number of documents we have, $n_i$ is the document frequency, i.e. number of documents that contain term $i$. $f_i$ is the term frequency in the document, and $qf_i$ is the term frequency in the query terms. The weighting parameters $k_1, k_2, K$ are set empirically (by science). $k_1$ and $k_2$ determine the importance of document term frequency and query term frequency respectively. $K$ is a normalized term, determined by:\n$$K = k_1((1-b)+b\\cdot \frac{dl}{avdl})$$\nWhere $b$ is a empirical parameter, $dl$ is the document length, and $avdl$ is the average length of all the documents we have. \n\\ \\\nWe could set the magic parameters to $k_1=1.1, k_2=10, b=0.6$. \n\\ \\\n\textbf{4.2. Query Likelihood. (formula information reference from: Search Engines,\nInformation Retrieval in Practice, by W.B. Croft, D. Metzler, T. Strohman, 2015)}\\\nQuery Likelihood is a well-known probabilistic retrieval model depends on language model. The smoothing techniques we use is Dirichlet smoothing. More specifically, we calculate the score for a document by:\n$$\\alpha_D P(q_i|D) + \\alpha_D P(q_i|C)$$\nwhere $P(q_i|D)$ is the probability of query term $i$ occur in document $D$, and $P(q_i|C)$ is the probability of query term $i$ occur in the entire collection $C$. $\\alpha_D$ is the Dirichlet smoothing coefficient determined by $\\alpha_D = \frac{\\mu}{|D| + \\mu}$, where $\\mu$ is set empirically. The final formula is:\n$$\frac{f_{q_i, D} + \\mu \frac{c_{q_i}}{|C|}}{|D| + \\mu}$$\nwhere $f_{q_i, D}$ is the term frequency in document $D$, and $c_{q_i}$ is the term frequency in entire collection $C$. We could set $\\mu = 1000$. ", "id": 4, "summery": "Details of the micro search engine, including the steps for query processing, indexing techniques, and retrieval models.", "tags": ["Software Engineering", "Full Stack", "Search Engine"], "title": "Low level Design -- Search Engine, Personal Website", "type": "documentation"}, "text": ["itl", "person", "websit", "low", "level", "design", "search", "engin", "author", "author", "yunfei", "luo", "maketitl", "extbf", "1", "overview", "includegraph", "scale", "0", "28", "back", "end", "overview", "jpg", "centerlin", "extbf", "figur", "1", "micro", "search", "engin", "architectur", "extbf", "2", "pre", "process", "extbf", "21", "process", "document", "independ", "interact", "frontend", "backend", "process", "done", "period", "whenev", "new", "articl", "ad", "databas", "process", "follow", "step", "token", "letter", "lower", "case", "remov", "dot", "abbrevi", "word", "ii", "stem", "snowbal", "stemmer", "call", "porter", "2", "iii", "stopword", "remov", "remov", "non", "signific", "word", "concis", "list", "python", "packag", "nltk", "extbf", "22", "process", "queri", "queri", "request", "come", "frontend", "queri", "term", "pre", "process", "queri", "function", "execut", "process", "step", "step", "process", "document", "21", "extbf", "3", "index", "invert", "index", "", "index", "main", "retriev", "model", "rank", "document", "given", "queri", "term", "invert", "index", "invert", "list", "contain", "necessari", "inform", "store", "term", "specif", "invert", "index", "defin", "map", "term", "mapsto", "map", "document", "id", "mapsto", "list", "posit", "exampl", "term", "learn", "occur", "document", "1", "3", "fifth", "word", "document", "1", "second", "word", "document", "2", "index", "term", "look", "learn", "mapsto", "document", "1", "mapsto", "1", "5", "document", "3", "mapsto", "2", "4", "term", "frequenc", "document", "length", "term", "doc", "id", "total", "length", "list", "posit", "document", "specifi", "id", "collect", "frequenc", "length", "list", "term", "extbf", "4", "retriev", "model", "key", "element", "rank", "document", "given", "queri", "term", "follow", "option", "algorithm", "extbf", "41", "bm25", "formula", "inform", "refer", "search", "engin", "inform", "retriev", "practic", "wb", "croft", "d", "metzler", "t", "strohman", "2015", "bm25", "bm", "stand", "best", "match", "known", "probabilist", "retriev", "model", "onli", "take", "document", "term", "frequenc", "account", "consid", "queri", "term", "frequenc", "micro", "search", "engin", "common", "form", "bm25", "refer", "inform", "specif", "score", "document", "given", "queri", "term", "calcul", "sum", "q", "log", "rac", "n", "n", "0", "5", "n", "0", "5", "cdot", "rac", "k", "1", "1", "f", "k", "f", "cdot", "rac", "k", "2", "1", "qf", "k", "2", "qf", "q", "set", "term", "queri", "term", "n", "total", "number", "document", "n", "document", "frequenc", "number", "document", "contain", "term", "", "f", "term", "frequenc", "document", "qf", "term", "frequenc", "queri", "term", "weight", "paramet", "k", "1", "k", "2", "k", "set", "empir", "scienc", "", "k", "1", "k", "2", "determin", "import", "document", "term", "frequenc", "queri", "term", "frequenc", "respect", "k", "normal", "term", "determin", "k", "k", "1", "1", "b", "b", "cdot", "rac", "dl", "avdl", "b", "empir", "paramet", "dl", "document", "length", "avdl", "averag", "length", "document", "set", "magic", "paramet", "k", "1", "1", "1", "k", "2", "10", "b", "0", "6", "", "extbf", "42", "queri", "likelihood", "formula", "inform", "refer", "search", "engin", "inform", "retriev", "practic", "wb", "croft", "d", "metzler", "t", "strohman", "2015", "queri", "likelihood", "known", "probabilist", "retriev", "model", "depend", "languag", "model", "smooth", "techniqu", "dirichlet", "smooth", "specif", "calcul", "score", "document", "alpha", "d", "p", "q", "d", "alpha", "d", "p", "q", "c", "p", "q", "d", "probabl", "queri", "term", "occur", "document", "d", "p", "q", "c", "probabl", "queri", "term", "occur", "entir", "collect", "c", "", "alpha", "d", "dirichlet", "smooth", "coeffici", "determin", "alpha", "d", "rac", "mu", "d", "mu", "mu", "set", "empir", "final", "formula", "rac", "f", "q", "d", "mu", "rac", "c", "q", "c", "d", "mu", "f", "q", "d", "term", "frequenc", "document", "d", "c", "q", "term", "frequenc", "entir", "collect", "c", "", "set", "mu", "1000", ""]}, "4": {"obj": {"docs": [], "path": "articles/blogs/paper_review_artistic_style.pdf", "text": "Paper Review\nAuthor: Yunfei Luo\nMay 12, 2020\n||||||||||||||||||||||||||||||||||||||||\nA Neural Algorithm of Artistic Style, by Gatys, Ecker, and Bethge\nReference Paper URL: https://arxiv.org/abs/1508.06576\nIntroduction/Main Goal\nThe paper was published in 2015. The main goal of the paper is to introduce an artificial system\nthat could create artistic images like what human could do with painting. The core of the system\nis a neural algorithm based on Deep Neural Networks. A sub-goal of the paper is to describe how\nhuman create and perceive artistic images, with algorithmic approach.\nWhat's New/Improvement\nThe authors are not trying improve, but rather, explore a new field of application of Deep Neural\nNetworks. They notice that, during the image processing by the neural networks, the actual features\n(the mapping of different filtered versions of image) and the correlation between different filters can\nbe individually visualized at each layer. They called them \"content representation\" and \"style rep-\nresentation\" respectively. So they are thinking about combining the representations of content and\nstyle to make something out.\nObservations\nAs a paper on the neural networks, the input and output in this case are both images, with the\nnormal image structures, i.e. the 2-D matrix of pixels. More specifically, the inputs are two images,\none for capturing the content representation, one for extracting style representation. The output is\nan image that combine the content and style representation through image reconstruction. More-\nover, there do exists a hidden state. Since during the match of content and style, if emphasizing\nmore on the content, it will be obvious to detect what was the original photograph with less variant\nin the style. Same as if emphasizing more on the style, then content of the image might be hard to\nsee, i.e. the image would be too abstractionism. So the hidden state would be some reconstructed\nimage with \"just-right\" weights for content and style.\nResult\nIn order to dealing with this tasks, the authors done it through a optimization problem on minimiz-\ning the linear combination of the loss functions of content and style. The weights, or the coe\u000ecients\nof the loss functions could be understand as the \"regularizers\" that serves for the extent of how much\nthe image emphasize on content and style. For the result that the authors got (page 5 in the paper):\n\nIt seems like the Deep Neural Networks perform pretty well on applying different artistic styles, from\nlearning of other artworks, on the photo shown in A. To intuitively interpret these results, the neu-\nral algorithm do effectively facsimile the photograph with artistic styles of some well-known artists,\nsuch as J.M.W. Turner and Vincent Van Gogh.\n\nExtension/Follow up\nWhat would happen if combining content with content, and style with style? An intuitive instance\nwould be, suppose that there is a photo of a cat, and another photo of a dog, what if we use the\ncontent representations of these two images from the Deep Neural Network for image reconstruc-\ntion? How to construct the optimization problem in this case, in order to made an image that have\nthe key content in both original images with relatively \"just right\" weights and positions? These\nfollow-up questions others the possible extension for the work presented in the paper.\n", "id": 6, "summery": "The main goal of the paper is to introduce an artificial system that could create artistic images like what human could do with painting.", "tags": ["Machine Learning", "Artificial Intelligence", "Neural Networks", "Numerical Optimization", "Image Processing"], "type": "blog", "title": "Image Reconstruction with Artistic Style, Paper Review"}, "text": ["paper", "review", "author", "yunfei", "luo", "12", "2020", "neural", "algorithm", "artist", "style", "gati", "ecker", "bethg", "refer", "paper", "url", "https", "arxiv", "org", "ab", "1508", "06576", "introduct", "main", "goal", "paper", "publish", "2015", "main", "goal", "paper", "introduc", "artifici", "system", "creat", "artist", "imag", "human", "paint", "core", "system", "neural", "algorithm", "base", "deep", "neural", "network", "sub", "goal", "paper", "describ", "human", "creat", "perceiv", "artist", "imag", "algorithm", "approach", "s", "new", "improv", "author", "tri", "improv", "explor", "new", "field", "applic", "deep", "neural", "network", "notic", "dure", "imag", "process", "neural", "network", "actual", "featur", "map", "differ", "filter", "version", "imag", "correl", "differ", "filter", "individu", "visual", "layer", "call", "content", "represent", "style", "rep", "resent", "respect", "think", "combin", "represent", "content", "style", "make", "someth", "observ", "paper", "neural", "network", "input", "output", "case", "imag", "normal", "imag", "structur", "2", "d", "matrix", "pixel", "specif", "input", "two", "imag", "captur", "content", "represent", "extract", "style", "represent", "output", "imag", "combin", "content", "style", "represent", "imag", "reconstruct", "exist", "hidden", "state", "sinc", "dure", "match", "content", "style", "emphas", "content", "obvious", "detect", "origin", "photograph", "variant", "style", "emphas", "style", "content", "imag", "hard", "imag", "abstraction", "hidden", "state", "reconstruct", "imag", "right", "weight", "content", "style", "result", "order", "deal", "task", "author", "done", "optim", "problem", "minimiz", "ing", "linear", "combin", "loss", "function", "content", "style", "weight", "coe", "cient", "loss", "function", "understand", "regular", "serv", "extent", "imag", "emphas", "content", "style", "result", "author", "got", "page", "5", "paper", "deep", "neural", "network", "perform", "pretti", "appli", "differ", "artist", "style", "learn", "artwork", "photo", "intuit", "interpret", "result", "neu", "ral", "algorithm", "effect", "facsimil", "photograph", "artist", "style", "known", "artist", "jmw", "turner", "vincent", "van", "gogh", "extens", "follow", "happen", "combin", "content", "content", "style", "style", "intuit", "instanc", "suppos", "photo", "cat", "anoth", "photo", "dog", "content", "represent", "two", "imag", "deep", "neural", "network", "imag", "reconstruc", "tion", "construct", "optim", "problem", "case", "order", "made", "imag", "key", "content", "origin", "imag", "relat", "right", "weight", "posit", "follow", "question", "possibl", "extens", "work", "present", "paper"]}, "5": {"obj": {"docs": [], "path": "articles/blogs/paper_review_char_level_text_classification.pdf", "text": "Paper Review\nAuthor: Yunfei Luo\nMay 12, 2020\n||||||||||||||||||||||||||||||||||||||||\nCharacter-level Convolutional Networks for Text Classi\fcation, by Zhang, Zhao, and LeCun\nReference Paper URL: https://arxiv.org/abs/1509.01626\nIntroduction/Main Goal\nThe paper was published in 2016. The main goal of the paper is to exemplify the performance of\nConvNets (Convolutional Networks) on text classification, based on Character-level. That is, to\nshow the ability of ConvNets understand the text (for the task of classification) without knowing\nthe knowledge from words and semantic structure of the language.\nWhat's New/Improvement\nThe authors are trying to improve upon the traditional text classification. As pointed by the au-\nthors, most of the machine learning classifiers for text classification nowadays are based on words.\nHowever, the authors offers a new approach to the task, i.e. treating the text as raw signal at char-\nacter level, rather than word level. More specifically, instead of present word at each entry of the\nvector representation for the text, the signal present single character at each entry. Such approach\nis supposed to be more effective and perform better with large scale dataset.\nObservations\nThis is also a paper on Neural Networks. The input is a text, and the output is a class that the\ntext belongs to. More specifically, the input text will be numerically transformed into a matrix with\ndimension m * l, such that m defines the domain of unit character depends on the input language,\nand l denotes the total length of the sequence of characters that we care about in the text. In this\npaper, the authors believe that l = 1014 is an appropriate length, since it is enough for catching\nthe key information in a text. The output class is simply in string format, for example, \"sport\",\n\"finance\", \"entertainment\", etc. Although in the paper, the authors use supervised learning to train\nthe Networks, all the class of the given texts are known, in practice, there do exist some unknown\nstate. The hidden node would be the actual class that the texts belong to. The topology of the\nhidden nodes could be several independent trees, each with a broad class as root. For example, the\nclass \"sport\", there would be some sub-class under this class, such as \"basketball\", \"swimming\",\n\"mixed martial arts\", etc.\nResult\nThe result that the authors obtained is shown as followed (page 6 in the paper):\n\nThe table of error shows that overall, the character-level ConvNets performed well. A more de-\ntailed comparison of the errors with other text classification model is offered at page 7:\n\nThe figure above shows that although the character-level ConvNets does not perform that well\nwith the dataset \"AG News\" compare with other models (except Bag-pf-means, because this model\nhas more errors in all the dataset cases), the overall values of errors made by the character-level\nConvNets is considerable. The most important point is that the character-level based ConvNets\ndoes not need dictionary for training, so that the entire training process is much more effective than\nthe other models.\nExtension/Follow up\nSome deficiency would be obvious that the character-level ConvNets might not perform well with\nnon-symbol-based language, such as Chinese. In this paper, the authors deal with this case (the\ndataset of Sogou News) by transform the Chinese characters into Pinyin. However, Pinyin and\nChinese characters are not an one-to-one mapping, but rather an onto mapping, from characters to\nPinyin. Placing different characters at the same place could mean extremely different things. So\nwould it be better if we split each character into strokes (such as point and across, which is also a\nfinite set), then use this sequence of strokes as raw input signals? Such follow-up questions could\nform the extension for the work presented in the paper.\n", "id": 7, "summery": "The main goal of the paper is to exemplify the performance of ConvNets (Convolutional Networks) on text classification, based on Character-level.", "tags": ["Machine Learning", "Artificial Intelligence", "Neural Networks", "Numerical Optimization", "Classification"], "type": "blog", "title": "Character Level Text Classification, Paper Review"}, "text": ["paper", "review", "author", "yunfei", "luo", "12", "2020", "charact", "level", "convolut", "network", "text", "classi", "cation", "zhang", "zhao", "lecun", "refer", "paper", "url", "https", "arxiv", "org", "ab", "1509", "01626", "introduct", "main", "goal", "paper", "publish", "2016", "main", "goal", "paper", "exemplifi", "perform", "convnet", "convolut", "network", "text", "classif", "base", "charact", "level", "show", "abil", "convnet", "understand", "text", "task", "classif", "know", "knowledg", "word", "semant", "structur", "languag", "s", "new", "improv", "author", "tri", "improv", "tradit", "text", "classif", "point", "au", "thor", "machin", "learn", "classifi", "text", "classif", "nowaday", "base", "word", "howev", "author", "offer", "new", "approach", "task", "treat", "text", "raw", "signal", "char", "acter", "level", "word", "level", "specif", "present", "word", "entri", "vector", "represent", "text", "signal", "present", "singl", "charact", "entri", "approach", "suppos", "effect", "perform", "better", "larg", "scale", "dataset", "observ", "paper", "neural", "network", "input", "text", "output", "class", "text", "belong", "specif", "input", "text", "numer", "transform", "matrix", "dimens", "m", "l", "m", "defin", "domain", "unit", "charact", "depend", "input", "languag", "l", "denot", "total", "length", "sequenc", "charact", "care", "text", "paper", "author", "believ", "l", "1014", "appropri", "length", "sinc", "catch", "key", "inform", "text", "output", "class", "simpli", "string", "format", "exampl", "sport", "financ", "entertain", "paper", "author", "supervis", "learn", "train", "network", "class", "given", "text", "known", "practic", "exist", "unknown", "state", "hidden", "node", "actual", "class", "text", "belong", "topolog", "hidden", "node", "sever", "independ", "tree", "broad", "class", "root", "exampl", "class", "sport", "sub", "class", "class", "basketbal", "swim", "mix", "martial", "art", "result", "result", "author", "obtain", "follow", "page", "6", "paper", "tabl", "error", "show", "overal", "charact", "level", "convnet", "perform", "de", "tail", "comparison", "error", "text", "classif", "model", "offer", "page", "7", "figur", "abov", "show", "charact", "level", "convnet", "doe", "perform", "dataset", "ag", "news", "compar", "model", "bag", "pf", "mean", "becaus", "model", "error", "dataset", "case", "overal", "valu", "error", "made", "charact", "level", "convnet", "consider", "import", "point", "charact", "level", "base", "convnet", "doe", "dictionari", "train", "entir", "train", "process", "effect", "model", "extens", "follow", "defici", "obvious", "charact", "level", "convnet", "perform", "non", "symbol", "base", "languag", "chines", "paper", "author", "deal", "case", "dataset", "sogou", "news", "transform", "chines", "charact", "pinyin", "howev", "pinyin", "chines", "charact", "map", "map", "charact", "pinyin", "place", "differ", "charact", "place", "mean", "extrem", "differ", "thing", "better", "split", "charact", "stroke", "point", "finit", "set", "sequenc", "stroke", "raw", "input", "signal", "follow", "question", "form", "extens", "work", "present", "paper"]}, "6": {"obj": {"docs": [], "path": "articles/reports/studentlife_spring2020_report.pdf", "text": "Independent Study Report\nUniversity of Massachusetts Amherst\nInstructors: Madalina Fiterau, Iman Deznabi\nStudent: Yunfei Luo\nSpring 2020\nMay 12, 2020\n||||||||||||||||||||||||||||||||||||||||\nPersonalized Student Stress Prediction with Deep Multitask Network\nAbstract\nIn this semester, I'm working on predicting student stress with putting students in groups, in order\nto explore the possibility to make the original personalized model more applicable. Though it is\nhard for the \"grouplized\" model to have better performance than the personalized model, my ex-\nperiments shows that grouping students by the average stress level could have F1 score that is really\nclose to the score achieved by the personalized model.\n1. Introduction and Previous work\nThe previous state-of-the-art model is called Cross-Personal Activity LSTM Multitask Auto-Encoder\nNetwork (CALM-Net), see Personalized Student Stress Prediction with Deep Multitask Network by\nAbhinav Shaw, Natcha Simsiri, Iman Deznabi, Madalina Fiterau, Tauhidur Rahman.\nThe model is constituted by a Long Term Short Memory (LSTM) autoencoder connected by fully\nconnected layers, then connected by sub multi-layer-perceptrons (MLP) for each students. I'm\nmainly working on the sub MLP part.\nThe main problem is that when we have a new student, without collecting some data from the\nstudent, it is hard for the personalized model to make prediction due to the lack in training data.\nSo for the sub MLP, instead of building them for each student, we build them for each group of\nstudents. So when a new student come, instead of collecting data from the student, we just need\nto collect some features of the students, then we could put the student into the group that contains\nstudents who share similar characteristics with the new student, then make prediction.\n\nFigure 1.Personalized Model\nFigure 2.Grouplized Model\n2. Background Information\nThe StudentLife dataset was conducted in Dartmouth college where passive sensing and survey data\nwas collected over 10 weeks among 48 students.\n3. Methods\n3.1. Density Based Clustering based on Dynamic Time Warping (DTW) on series of stress labels\nThe stress labels we have for each student form a time series data. Since the stress labels for\n\nthe students falls in different set of days during the 2 months range, using distance criteria like Eu-\nclidean and Manhattan distance is not reasonable. In order to find the similarity among students,\nstudents can be clustered based on the DTW distance, that considering the distortion of the data.\nSince each student have different number of stress label recorded, the lengths of these time se-\nries data are different. So the methods based on finding centroids such K-Means and Mean-shift are\nnot applicable. Instead, hierarchical clustering methods can be used in this case. Density-Based-\nSpatial-Clustering-of-Applications-with-Noise (DBSCAN) is the one I used for clustering these series\ndata. The noise data points were greedily assigned to the existed groups that are the closest to them.\nFigure 3. samples of clusters.\nThe x-axis is the time (days in a year + (hours in the day / 24)), the y-axis is the stress label\n\n3.2. K-Means Clustering on aggregated stress labels, i.e. average stress labels\nConsidering that the density based clustering methods based on DTW is a bit complex, I sim-\nply aggregated the series data with their means to be the data point. Then the clustering becomes\nmuch easier. Though I use K-Means for clustering, it is nothing but put thresholds to split the data\npoints.\nFigure 4. clusters visualize, where x-axis is the average stress labels\n3.3. Density Based Clustering on chosen features from aggregated surveys score\nThe ideal way is to clustering students based on surveys score. So for a new student, we could\nfirst collect the survey results, then put the student in to proper cluster. For now, I had use the\nfeatures: average hours slept, average deadline per week, and mode sleep rating. In order to guar-\nantee that in the training dataset, no group contains only one student, I use the same methods in\n3.1: use DBSCAN first, then put the noise data in the closest clusters.\n\nFigure 5. Clusters visualize with three chosen features from surveys\n4. Experiment results:\nThe model evaluation method I used is 5-fold cross validation. The metrics include F1 score and\nAUC were averaged across the 5 splits. I've also include the results of original data in the table, i.e.\neach group contain exactly one student.\nTable 1. The best results that each different clustering method obtained\n5. Conclusion and Future work\nThe results from experiments shows that using clusters based on average stress labels has better\n\nperformance. However, in order to know how well a model performed, we need to run leave one out\nvalidations, which haven't being completed. After that, we could know how the model generalized\namong each individual.\nIn addition, there are still many other surveys scores that haven't been used in clustering. In\norder to use these features, I need to do more work on knowing how the scores of different types of\nsurveys are aggregated.\nA. Appendix\nA.1. Model Configuration\nWeights for Losses: alpha = 0:0001 for autoencoder reconstruction error, beta = 1 for classi\fcation error\nAuto-Encoder bottleneck size: 128\nShared Layer size: 256\nUser(Group) Layer size: 64\nEpochs: 500\nGradient Descent step size: 0.000001\nL2 norm regularization coeff: 0.0001\nDropout probabilities: None\nValidation method: 5-fold validation, strati\fed splitting by the group-id/stress-label pairs\n", "id": 5, "summery": "Open source project on predicting student's stress with Multitask Learning and Time series data. The Dataset, StudentLife, was collected by a program in Dartmouth College.", "tags": ["Machine Learning", "Artificial Intelligence", "Open Source", "Neural Networks"], "type": "report", "title": "Student Stress Prediction, Machine Learning Research Project"}, "text": ["independ", "studi", "report", "univers", "massachusett", "amherst", "instructor", "madalina", "fiterau", "iman", "deznabi", "student", "yunfei", "luo", "spring", "2020", "12", "2020", "person", "student", "stress", "predict", "deep", "multitask", "network", "abstract", "semest", "m", "work", "predict", "student", "stress", "put", "student", "group", "order", "explor", "possibl", "make", "origin", "person", "model", "applic", "hard", "groupliz", "model", "better", "perform", "person", "model", "ex", "periment", "show", "group", "student", "averag", "stress", "level", "f1", "score", "realli", "close", "score", "achiev", "person", "model", "1", "introduct", "previous", "work", "previous", "state", "art", "model", "call", "cross", "person", "activ", "lstm", "multitask", "auto", "encod", "network", "calm", "net", "person", "student", "stress", "predict", "deep", "multitask", "network", "abhinav", "shaw", "natcha", "simsiri", "iman", "deznabi", "madalina", "fiterau", "tauhidur", "rahman", "model", "constitut", "long", "term", "short", "memori", "lstm", "autoencod", "connect", "fulli", "connect", "layer", "connect", "sub", "multi", "layer", "perceptron", "mlp", "student", "m", "main", "work", "sub", "mlp", "part", "main", "problem", "new", "student", "collect", "data", "student", "hard", "person", "model", "make", "predict", "due", "lack", "train", "data", "sub", "mlp", "build", "student", "build", "group", "student", "new", "student", "come", "collect", "data", "student", "collect", "featur", "student", "put", "student", "group", "contain", "student", "share", "similar", "characterist", "new", "student", "make", "predict", "figur", "1", "person", "model", "figur", "2", "groupliz", "model", "2", "background", "inform", "studentlif", "dataset", "conduct", "dartmouth", "colleg", "passiv", "sens", "survey", "data", "collect", "10", "48", "student", "3", "method", "31", "densiti", "base", "cluster", "base", "dynam", "time", "warp", "dtw", "seri", "stress", "label", "stress", "label", "student", "form", "time", "seri", "data", "sinc", "stress", "label", "student", "fall", "differ", "set", "dure", "2", "month", "rang", "distanc", "criteria", "eu", "clidean", "manhattan", "distanc", "reason", "order", "find", "similar", "student", "student", "cluster", "base", "dtw", "distanc", "consid", "distort", "data", "sinc", "student", "differ", "number", "stress", "label", "record", "length", "time", "se", "rie", "data", "differ", "method", "base", "find", "centroid", "k", "mean", "mean", "shift", "applic", "hierarch", "cluster", "method", "case", "densiti", "base", "spatial", "cluster", "applic", "nois", "dbscan", "cluster", "seri", "data", "nois", "data", "point", "greedili", "assign", "exist", "group", "closest", "figur", "3", "sampl", "cluster", "x", "axi", "time", "hour", "24", "y", "axi", "stress", "label", "32", "k", "mean", "cluster", "aggreg", "stress", "label", "averag", "stress", "label", "consid", "densiti", "base", "cluster", "method", "base", "dtw", "bit", "complex", "sim", "pli", "aggreg", "seri", "data", "mean", "data", "point", "cluster", "becom", "easier", "k", "mean", "cluster", "noth", "put", "threshold", "split", "data", "point", "figur", "4", "cluster", "visual", "x", "axi", "averag", "stress", "label", "33", "densiti", "base", "cluster", "chosen", "featur", "aggreg", "survey", "score", "ideal", "way", "cluster", "student", "base", "survey", "score", "new", "student", "collect", "survey", "result", "put", "student", "proper", "cluster", "featur", "averag", "hour", "averag", "deadlin", "mode", "sleep", "rate", "order", "guar", "ante", "train", "dataset", "group", "contain", "onli", "student", "method", "3", "1", "dbscan", "put", "nois", "data", "closest", "cluster", "figur", "5", "cluster", "visual", "three", "chosen", "featur", "survey", "4", "experi", "result", "model", "evalu", "method", "5", "fold", "cross", "valid", "metric", "includ", "f1", "score", "auc", "averag", "5", "split", "ve", "includ", "result", "origin", "data", "tabl", "group", "contain", "exact", "student", "tabl", "1", "best", "result", "differ", "cluster", "method", "obtain", "5", "conclus", "futur", "work", "result", "experi", "show", "cluster", "base", "averag", "stress", "label", "better", "perform", "howev", "order", "know", "model", "perform", "run", "leav", "valid", "haven", "t", "complet", "know", "model", "general", "individu", "addit", "mani", "survey", "score", "haven", "t", "cluster", "order", "featur", "work", "know", "score", "differ", "type", "survey", "aggreg", "appendix", "a1", "model", "configur", "weight", "loss", "alpha", "0", "0001", "autoencod", "reconstruct", "error", "beta", "1", "classi", "cation", "error", "auto", "encod", "bottleneck", "size", "128", "share", "layer", "size", "256", "user", "group", "layer", "size", "64", "epoch", "500", "gradient", "descent", "step", "size", "0", "000001", "l2", "norm", "regular", "coeff", "0", "0001", "dropout", "probabl", "valid", "method", "5", "fold", "valid", "strati", "ed", "split", "group", "id", "stress", "label", "pair"]}}